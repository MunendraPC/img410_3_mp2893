raycast: width (500) height (500) scene.scene output.ppm (p3 format image)
argv[0]		argv[1]		argv[2]		argv[3]		argv[4]		
			ppm_w		ppm_h		scene_file	output_file // assign to variables
check argc != 5, close the program and print error: printf("Usage: raycast width height scene.scene output.ppm")

class shape{

	virtual void intersect();

}
typdef struct sphere : shape{

}sphere;

typdef struct plane : shape{

}sphere;

bool readscene(...){
	fscanf()->magic number "img410"->error return false
	while(...){
		
		fscanf() = {"sphere", "plane", "camera"}
			while(){
				fscanf() = {"width", "height, "color, "position", "normal", "radius"}
			}
	}
} // hold in an array of ptrs, linked list, or static array (objects[])


void renderScene(){
	for y in the image height
		for x in the image width
			R0 = {0,0,0}
			Rd = {-1/2 camera_width + x * delta_x + offset (1/1000), // delta x camera_width/img_height 
				 -1/2 camera_height + y * delta_y + offset (1/1000), // delta y camera_height/img_height
				 -1}
			normalize(rd);
			
			min_t = infinity;
			intersection_obj = NULL;
			
			for object in object 
				intersection with each object
				object->intersect(R0, Rd) -> t0, t1
				min_t = min(t0, t1) // write function to compare the t values
				if min_t is updated then update intersection obj
				pixmap[...] = intersection, c_diff <- float uint_8 -> x 225
				// if no intersection, assign black
}

void write_ppm(){
	// paste code
}